import { NextRequest, NextResponse } from "next/server";
import connectToDatabase from "@/lib/mongodb"; import Stationary from "@/lib/models/Book"; import Product from "@/lib/models/Product"; import { stationarySchema, productSchema } from "@/lib/validators"; import { z } from "zod"; import mongoose from "mongoose"; import { getServerSession } from "next-auth"; import { authOptions } from "@/app/api/auth/[...nextauth]/route";  // GET /api/product/flower/[id] export async function GET(: NextRequest, { params }: { params: { id: string } }) {     const par = await params;     const id = par.id;     await connectToDatabase();     const stnry = await Stationary.findById(id);     console.log(stnry);     if (!stnry) return NextResponse.json({ error: "Stationary not found" }, { status: 404 });     return NextResponse.json(stnry); }  // PUT si inputul pentru book si product const inputSchema = z.object({     stationary: stationarySchema.partial(),     product: productSchema.omit({ refId: true, type: true, typeRef: true }) });  export async function PUT(req: NextRequest, { params }: { params: { id: string } }) {     const session = await getServerSession(authOptions);     if (!session || (session.user as any).role !== "admin") {         return NextResponse.json({ error: "Doar adminii pot crea produse" }, { status: 403 });     }     await connectToDatabase();     const body = await req.json();      const parsed = inputSchema.safeParse(body);     if (!parsed.success) {         return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });     }      const { stationary, product } = parsed.data;      const updatedFlwr = await Stationary.findByIdAndUpdate(params.id, stationary, { new: true });     if (!updatedFlwr) return NextResponse.json({ error: "Flower not found" }, { status: 404 });      const updatedProduct = await Product.findOneAndUpdate(         { refId: new mongoose.Types.ObjectId(params.id), type: "stationary" },         { ...product },         { new: true }     );      return NextResponse.json({ updatedFlwr, updatedProduct }); }    // DELETE /api/product/book/[id] export async function DELETE(: NextRequest, { params }: { params: { id: string } }) {     const session = await getServerSession(authOptions);     if (!session || (session.user as any).role !== "admin") {         return NextResponse.json({ error: "Doar adminii pot crea produse" }, { status: 403 });     }     await connectToDatabase();      // Ștergem întâi produsul asociat     const deletedProduct = await Product.findOneAndDelete({         refId: new mongoose.Types.ObjectId(params.id),         type: "stationary"     });      // Apoi ștergem cartea     const deletedStationary = await Stationary.findByIdAndDelete(params.id);      if (!deletedStationary) {         return NextResponse.json({ error: "Stationary not found (product might have been deleted)" }, { status: 404 });     }      return NextResponse.json({         message: "Stationary and associated Product deleted",         deletedProductId: deletedProduct?._id,         deletedBookId: deletedStationary._id     }); }  asa arata ruta de preluare individuala si asa este interfata din types a ProductEntry care se ocupa cu tipizarea componentei //interfate pentru diferitele tipuri de colectii export interface Subcategory {     _id: string;     name: string;     description: string;     image: string;     type: string; }  export interface Review {     user: String,     product: String,     rating: Number,     comment: String, } export interface ProductEntry {     _id: string;     name: string;     description: string;     price: number;     image: string;     stock: number;     type: "book" | "stationary" | "flower";     typeObject?: Book | Stationary | Flower;     typeRef: "Book" | "Stationary" | "Flower";     refId: string;     createdAt: string;     updatedAt: string;     subcategories: Subcategory[];     reviews: Review[];     discount: number; } export interface Book {     author: String,     pages: Number,     isbn: String,     publisher: String,     genre: String,     language: String,     publicationDate: Date };  export interface Flower {     color: String,     freshness: Number,     lifespan: Number,     season: String,     careInstructions: String,     expiryDate: Date };  export interface Stationary {     brand: String,     color: [String],     type: String,     price: Number,     dimensions: {         height: Number,         width: Number,         depth: Number     },     material: String };  export interface User {     _id: string;     firstName: string;     lastName: string;     email: string;     role: string;     createdAt: string;     updatedAt: string; } 